---
---
<div id="tech-visual-container">
  <div class="scanline-overlay"></div>
</div>

<script>
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';

  const container = document.getElementById('tech-visual-container');

  if (container) {
    // --- MOBILE DETECTION ---
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
    
    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.05); // Deep fog for infinite depth

    // Adjust FOV for mobile (wider view)
    const fov = isMobile ? 80 : 70;
    const camera = new THREE.PerspectiveCamera(fov, container.clientWidth / container.clientHeight, 0.1, 100);
    camera.position.z = 5; 

    // Lower pixel ratio on mobile for performance
    const pixelRatio = isMobile ? 1 : Math.min(window.devicePixelRatio, 2);
    
    const renderer = new THREE.WebGLRenderer({ 
      alpha: false, 
      antialias: !isMobile // Disable antialiasing on mobile
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(pixelRatio);
    renderer.setClearColor(0x000000, 1); 
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    // --- TUNNEL GEOMETRY ---
    const ringCount = isMobile ? 50 : 100;
    const tunnelDepth = 100;
    
    // Create rings with glowing borders
    const rings = [];
    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    for(let i = 0; i < ringCount; i++) {
        // Simpler geometry on mobile
        const segments = isMobile ? 64 : 100;
        const ringGeo = new THREE.TorusGeometry(3, 0.08, 16, segments);
        
        // Extract edges for the glowing border effect
        const edges = new THREE.EdgesGeometry(ringGeo);
        
        // Create line material for neon glow effect
        const lineMat = new THREE.LineBasicMaterial({
            color: 0xffffff,  // Start with white
            linewidth: 2,     // Thicker lines for visibility
            transparent: true,
            opacity: 1.0
        });
        
        // Create the glowing border as lines
        const ring = new THREE.LineSegments(edges, lineMat);
        
        // Position rings
        const zPos = - (i / ringCount) * tunnelDepth;
        ring.position.z = zPos;
        
        // Store metadata for animations
        ring.userData.initialZ = zPos;
        ring.userData.index = i;
        ring.userData.layer = i % 3; // 3 layers with different speeds
        
        rings.push(ring);
        ringGroup.add(ring);
    }

    // --- PARTICLE SYSTEM (Stars/Dust) ---
    const particleCount = isMobile ? 200 : 500;
    const particlesGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    
    for(let i = 0; i < particleCount; i++) {
        particlePositions[i * 3] = (Math.random() - 0.5) * 20;     // x
        particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 20; // y
        particlePositions[i * 3 + 2] = -Math.random() * tunnelDepth; // z
    }
    
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.05,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);

    // --- LIGHTING ---
    const light = new THREE.PointLight(0xffffff, 3, 40);
    light.position.set(0, 0, 5);
    scene.add(light);
    
    // Blue rim light for depth
    const rimLight = new THREE.PointLight(0x00f3ff, 1, 50);
    rimLight.position.set(0, 5, -10);
    scene.add(rimLight);
    
    scene.add(new THREE.AmbientLight(0x111111)); // Dark ambient

    // --- POST-PROCESSING ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(container.clientWidth, container.clientHeight),
        0.5, 0.4, 0.85
    );
    // Adjust bloom for mobile
    bloomPass.strength = isMobile ? 1.0 : 1.5;  
    bloomPass.radius = isMobile ? 0.4 : 0.6;    
    bloomPass.threshold = isMobile ? 0.15 : 0.1;
    composer.addPass(bloomPass);

    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // --- MOUSE PARALLAX ---
    let mouseX = 0;
    let mouseY = 0;
    let targetMouseX = 0;
    let targetMouseY = 0;
    
    const onMouseMove = (event) => {
        targetMouseX = (event.clientX / window.innerWidth) * 2 - 1;
        targetMouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    };
    
    if (!isMobile) {
        window.addEventListener('mousemove', onMouseMove);
    }

    // --- ANIMATION ---
    const clock = new THREE.Clock();
    
    // Helper: Linear Interpolation
    const lerp = (start, end, t) => start + (end - start) * t;
    
    // Scroll State
    let targetScroll = 0;
    let smoothScroll = 0;
    let currentSpeed = 8.0;
    let lastScrollY = 0;
    let scrollDirection = 1; // 1 = down, -1 = up
    
    // Color State (start B&W)
    let currentHue = 0;
    let currentSaturation = 0; // Start at 0 for B&W
    let currentLightness = 0.15;
    
    const updateScroll = () => {
        const scrollY = window.scrollY;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        targetScroll = Math.min(Math.max(scrollY / docHeight, 0), 1);
        
        // Detect scroll direction
        scrollDirection = scrollY > lastScrollY ? 1 : -1;
        lastScrollY = scrollY;
    };
    window.addEventListener('scroll', updateScroll);
    
    // Color Mapping Per Section
    const getSectionColor = (progress) => {
        // 0-25%: B&W → Cyan
        if (progress < 0.25) {
            const t = progress / 0.25;
            return {
                hue: 0.5,        // Cyan
                saturation: t,   // Gradually introduce color
                lightness: 0.15
            };
        }
        // 25-50%: Cyan → Purple
        else if (progress < 0.5) {
            const t = (progress - 0.25) / 0.25;
            return {
                hue: lerp(0.5, 0.75, t), // Cyan to Purple
                saturation: 1.0,
                lightness: 0.15
            };
        }
        // 50-75%: Purple → Green
        else if (progress < 0.75) {
            const t = (progress - 0.5) / 0.25;
            return {
                hue: lerp(0.75, 0.33, t), // Purple to Green
                saturation: 1.0,
                lightness: 0.15
            };
        }
        // 75-100%: Green → Orange
        else {
            const t = (progress - 0.75) / 0.25;
            return {
                hue: lerp(0.33, 0.08, t), // Green to Orange
                saturation: 1.0,
                lightness: 0.15
            };
        }
    };

    const animate = () => {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();
        
        // 1. Smooth Scroll
        smoothScroll = lerp(smoothScroll, targetScroll, 0.05);

        // 2. Mouse Parallax (smooth camera movement)
        if (!isMobile) {
            mouseX = lerp(mouseX, targetMouseX, 0.05);
            mouseY = lerp(mouseY, targetMouseY, 0.05);
            
            camera.position.x = mouseX * 0.5;
            camera.position.y = mouseY * 0.5;
            camera.lookAt(0, 0, 0);
        }

        // 3. Resolve Color
        const targetColor = getSectionColor(smoothScroll);
        currentHue = lerp(currentHue, targetColor.hue, 0.03);
        currentSaturation = lerp(currentSaturation, targetColor.saturation, 0.03);
        currentLightness = lerp(currentLightness, targetColor.lightness, 0.03);

        // 4. Speed Control
        const targetSpeed = 1.0 + (smoothScroll * 2.0); 
        currentSpeed = lerp(currentSpeed, targetSpeed, 0.05);

        // 5. Dynamic Lighting
        light.intensity = 3 + Math.sin(time * 2) * 1.0;
        rimLight.intensity = 1.5 + Math.sin(time * 1.5) * 0.5;

        // 6. Animate Particles (stars/dust moving)
        const particlePositions = particles.geometry.attributes.position.array;
        for(let i = 0; i < particleCount; i++) {
            // Reverse particle movement when scrolling up
            particlePositions[i * 3 + 2] += currentSpeed * delta * 0.5 * scrollDirection;
            
            // Loop particles (both directions)
            if(particlePositions[i * 3 + 2] > 5) {
                particlePositions[i * 3 + 2] = -tunnelDepth;
            } else if(particlePositions[i * 3 + 2] < -tunnelDepth) {
                particlePositions[i * 3 + 2] = 5;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;

        // 7. Update Rings with Multi-Layer Speeds & Depth Effects
        rings.forEach((ring, index) => {
            // Multi-layer speed (different layers move at different speeds)
            const layerSpeedMultiplier = 1 + (ring.userData.layer * 0.15);
            const ringSpeed = currentSpeed * layerSpeedMultiplier;
            
            // Movement - REVERSE when scrolling up for "sucked in" effect
            ring.position.z += ringSpeed * delta * scrollDirection;
            
            // Loop (both directions)
            if(ring.position.z > 5) {
                ring.position.z -= tunnelDepth;
            } else if(ring.position.z < -tunnelDepth) {
                ring.position.z += tunnelDepth;
            }
            
            // Rotation - also reverse when scrolling up
            const dir = index % 2 === 0 ? 1 : -1;
            ring.rotation.z += delta * 0.2 * dir * scrollDirection;
            
            // DEPTH EFFECTS FOR REALISM
            const distanceFromCamera = Math.abs(ring.position.z - camera.position.z);
            const normalizedDistance = distanceFromCamera / tunnelDepth;
            
            // Perspective Scaling (rings get smaller in distance)
            const scale = 1 + (normalizedDistance * 0.3);
            ring.scale.set(scale, scale, scale);
            
            // Depth-based Opacity (fade distant rings)
            const opacity = Math.max(0.2, 1 - (normalizedDistance * 0.8));
            ring.material.opacity = opacity;
            
            // Subtle Floating Motion (adds organic feel)
            const floatOffset = Math.sin(time * 0.5 + index * 0.1) * 0.05;
            ring.position.y = floatOffset;
            ring.position.x = Math.cos(time * 0.3 + index * 0.15) * 0.03;
            
            // Color with depth gradient
            const ringHue = (currentHue + (index * 0.002)) % 1.0;
            const depthBrightness = currentLightness * (2 + normalizedDistance); // Brighter when closer
            
            // Change the line color for the glowing border effect
            ring.material.color.setHSL(ringHue, currentSaturation, depthBrightness);
        });
        
        // Always visible - no fade out
        composer.render();
    };

    animate();

    // RESIZE
    window.addEventListener('resize', () => {
        if (!container) return;
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;
        
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(newWidth, newHeight);
        composer.setSize(newWidth, newHeight);
    });
  }
</script>

<style>
  #tech-visual-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 0; /* Behind content */
    background: transparent;
    pointer-events: none; /* Let clicks pass */
  }

  .scanline-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.15) 0px,
      transparent 1px,
      transparent 2px,
      rgba(0, 0, 0, 0.15) 3px
    );
    pointer-events: none;
    opacity: 0.3;
    animation: scanline 8s linear infinite;
  }

  @keyframes scanline {
    0% {
      transform: translateY(0);
    }
    100% {
      transform: translateY(10px);
    }
  }
</style>
