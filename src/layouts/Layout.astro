---
import '../styles/global.css';
import '@fontsource/space-grotesk';
import '@fontsource/outfit';

interface Props {
	title: string;
	description?: string;
}

const { title, description = "Vatsa Joshi - Creative Technologist" } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
	</head>
	<body>
		<slot />
        <script>
            // Custom Cursor Logic
            const cursor = document.createElement('div');
            cursor.classList.add('custom-cursor');
            document.body.appendChild(cursor);
            document.body.classList.add('cursor-active');

            const updateCursor = (e: MouseEvent) => {
                const style = document.createElement('style');
                style.innerHTML = `
                    body::after {
                        left: ${e.clientX}px;
                        top: ${e.clientY}px;
                    }
                `;
                // Optimized way would be using transform in JS directly instead of style injection,
                // but for simple singular element styling let's use direct style manipulation
                // actually let's do it properly without style injection churn
            };
            
            // Re-implementing cleaner logic
             const moveCursor = (e: MouseEvent) => {
                 document.body.style.setProperty('--cursor-x', `${e.clientX}px`);
                 document.body.style.setProperty('--cursor-y', `${e.clientY}px`);
             }
             
             // Updating globa.css to use variables for performance
             // Actually, let's keep it simple.
             
            document.addEventListener('mousemove', (e) => {
                 // We will update the pseudo element via a specialized class or just a real element
                 // The global.css uses body::after. We can't easily update pseudo css variables effectively without style attribute on body
                 // So let's add a real div in this script instead of the pseudo element approach in CSS?
                 // Wait, the CSS already defines body::after.
                 // Let's change the strategy to a real div.
            });
        </script>
        <div id="cursor-dot"></div>
        <div id="cursor-outline"></div>
        
        <style>
            #cursor-dot, #cursor-outline {
                position: fixed;
                top: 0;
                left: 0;
                transform: translate(-50%, -50%);
                border-radius: 50%;
                pointer-events: none;
                z-index: 9999;
            }
            #cursor-dot {
                width: 8px;
                height: 8px;
                background-color: var(--accent-cyan);
            }
            #cursor-outline {
                width: 40px;
                height: 40px;
                border: 1px solid rgba(255, 255, 255, 0.5);
                transition: transform 0.15s ease-out;
            }
        </style>
        <script>
            const dot = document.getElementById('cursor-dot');
            const outline = document.getElementById('cursor-outline');
            
            window.addEventListener('mousemove', (e) => {
                const posX = e.clientX;
                const posY = e.clientY;
                
                // Dot follows immediately
                if(dot) dot.style.left = `${posX}px`;
                if(dot) dot.style.top = `${posY}px`;
                
                // Outline follows with slight delay (animation is handled by css transition usually, 
                // but for exact "follow" feel we might animate via JS or just set pos and let CSS transition handle smoothing)
                 if(outline) {
                     outline.animate({
                         left: `${posX}px`,
                         top: `${posY}px`
                     }, { duration: 500, fill: "forwards" });
                 }
            });
            
            // Hover effects
            const interactiveElements = document.querySelectorAll('a, button');
            interactiveElements.forEach(el => {
                el.addEventListener('mouseenter', () => {
                    outline?.style.setProperty('transform', 'translate(-50%, -50%) scale(1.5)');
                    outline?.style.setProperty('border-color', 'var(--accent-cyan)');
                });
                el.addEventListener('mouseleave', () => {
                    outline?.style.setProperty('transform', 'translate(-50%, -50%) scale(1)');
                    outline?.style.setProperty('border-color', 'rgba(255, 255, 255, 0.5)');
                });
            })
        </script>
	</body>
</html>
